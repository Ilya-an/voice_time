/**@authors Илья Андреев
 * @version 1.0
 * @date 02.02.17
 * Данная программа озвучивает текущее время, используя синтезатор речи Festival. При её запуске, голос сообщит текущее время,
 * например, "Время - 17 часов, тридцать две минуты".
 * 
 * Требования для работы программы
 * Для корректной работы, разумеется, необходим сам синтезатор речи Festival, все зависящие от него пакеты и
 * festfox-ru - русский мужской голос для Festival. Данная программа тестировалась только на Linux, но должна работать
 * на всех Unix-подобных системах, на которых установлено выше перечисленное.
 * 
 * Принцип работы
 * В функции main вызывается функция settime, в которой вычисляется текущий час и минута, затем, в зависимости от этих значений, в функциях type_hour и type_min
 * выясняется, когда нужно говорить, "час", "часов" или "часа" (type_hour) и "минута", "минуты" или "минут" (type_min).
 * Например, 1 час, 2 часа, 21 минута или 22 минуты.
 * 
 * Для того, чтобы преобразовать число в его словесную форму, используется функция "transl_number".
 * Чтобы найти, является ли, например, строка "два" окончанием строки "двадцать два" (с помощью функции strstr можно получить
 * ложное срабатывание, например при "двадцать три", где "два" тоже есть) используется функция find_tail (поиск хвоста), а для
 * её замены - функция replace_tail (замена хвоста)
 * 
 * Также, в словесном выражении минут, нужно заменять слова "один" и "два", стоящие в конце, на "одна" и "две" соответственно,
 * (просклонять) для того, чтобы было созвучно со словами "минута" и "минуты" соответственно.
 * 
 * Затем, полученное предложение записывается в файл "voice_time.txt", создаваемый во временном каталоге /tmp. На этом, работа
 * функции settime прекращается.
 * Потом, путь к файлу передаётся синтезатору речи Festival, который и зачитывает содержимое файла.
 * 
 * Планируемые нововедения
 *  1. добавление возможности, при указании флага "-s", зачитывание, помимо часов и минут, количество секунд
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdbool.h>
#include <time.h>

/**
 * @fn transl_number
 * (перевод числа) 
 * @brief Функция для препобразования числа, записанного в цифровом формате, в письменный вид
 * Функция преобразовывает значение строки, в которой хранится число в цифровом формате, в число, записанное в письменном виде.
 * Например, функция преобразует строку "05" в строку "пять", "12" - в "двеннадцать", "45" - в "сорок пять", "66" - в... а ни в чего, 
 * потому что стоит функция будет работать только с числами в диапазоне от 0 до 59, хотя, при желании, этот диапазон можно расширить,
 * но в рамках данной программы в этом нет необходимости.
 * 
 * Принимает - указатель на строку "str_num"
 * Возвращает:
 *  1. "0", если содержимое переданной строки содержит что-то, помимо числа, например "1с" или число не прописывается в ограничение >= 0 и <= 59
 * 	2. указатель на строку "str_num", в которой хранится число словами, если всё прошло хорошо
 * 
 * Важно заметить, что для корректной работы функции, строке, на которую указывает указатель, было выделено не менее 60 байт памяти.
 * 
 * @param number_dig - входящее число, преобразованное в тип int
 * @param first_dig, second_dig - первые и вторые цифры числа соответственно
 * @param *dec, *units, *dec_twen - указатели на массивы строк, в которых хранятся все необходимые нам слова 
 */
char* transl_number (char* str_num)
{
	int number_dig, first_dig, second_dig;
	char *dec [] = {"десять", "двадцать", "тридцать", "сорок", "пятьдесят"};
	char *units [] = {"ноль", "один", "два", "три", "четыре", "пять", "шесть", "семь", "восемь", "девять"};
	char *dec_twen [] = {"одиннадцать", "двеннадцать", "триннадцать", "четырнадцать", "пятнадцать", "шестнадцать", "семнадцать", "восемьнадцать", "девятнадцать"};
	
	/// В этом блоке мы проверяем передаваемую строку на правильность. В ней должно быть число, которое будет от 0 до 59
	number_dig = atoi (str_num);
	if (number_dig < 0 && number_dig > 59)
		return 0;
	else if (number_dig == 0)						/// Функция atoi возвращает 0, если всё плохо, но она также может возвратить 0,
			if (strcmp (str_num, "00") != 0)		/// если 0 был в строке, поэтому и было добавленно ещё одно условие
				return 0;
				
	first_dig = number_dig / 10;					/// В first_dig - первая цифра числа number_dig
	second_dig = number_dig - (first_dig * 10);		/// В second_dig - вторая цифра числа number_dig
	if (first_dig != 0)
		strcpy (str_num, dec [first_dig - 1]);		/// Сначала копируем "десятки"
	else
		return strcpy (str_num, units [second_dig]);/// Если первая цифра равна 0, то можно сразу же возвращать единицы домой
	
	if (first_dig == 1 && second_dig != 0)			/// Проверяем на частный случай чисел диапазона от 11 до 19
		strcpy (str_num, dec_twen [second_dig]);	
	else
		if (second_dig != 0)
		{
			strcat (str_num, " ");					/// Добавляем пробел
			strcat (str_num, units [second_dig]);	/// А затем дописываем единицы
		}
		else if (first_dig == 0)
				strcpy (str_num, units [0]);		/// Пишем 0, когда всё по нулям
	
	return str_num;
}

/**
 * @fn find_tail
 * (поиск хвоста)
 * @brief Функция, которая определяет, является ли строка "*tail" окончанием строки "*line"
 * Сначала мы ищем длину каждой переданной строки, затем перемещаем указатель первой строки на количество символов, равное её длине,
 * вычесть длину второй строки. Например, если длина первой строки 11, а второй 4, то тогда мы смещаем указатель на 11-4=7.
 * Затем сравниваем полученный хвост первой строки со второй строкой и возвращем "true", если всё хорошо, или false, если не очень
 * 
 * Принимает:
 *  1. указатель на строку "*line" (строка), в которой будет искаться "*tail"
 * 	2. указатель на строку "*tail" (хвост), которая будет проверяться на вхождениние в конец строки "*line"
 * 
 * Возвращает: "true", если "*tail" является хвостом "*line" и "false", если не является
 * 
 * @param quan_line (quantity - количество) - количество символов в строке *line
 * @param quan_tail - количество символов в строке *tail
 */
bool find_tail (char *line, char *tail)
{
	int quan_line = strlen (line);
	int quan_tail = strlen (tail);
	line = line + quan_line - quan_tail;			/// Перемещаем указатель строки на нужное нам место
	if (strstr (line, tail) != NULL)				/// Проверяем, является ли всё что после указателя line строкой *tail
		return true;
	else
		return false;
}

/**
 * @fn replace_tail
 * (замена хвоста)
 * @brief Функция, которая заменяет строкой "tail" конец строки "line"
 * Сначала мы ищем длину каждой переданной строки, затем перемещаем указатель первой строки на количество символов, равное её длине,
 * вычесть длину второй строки. Например, если длина первой строки 11, а второй 4, то тогда мы смещаем указатель на 11-4=7.
 * Затем разбиваем строку на месте указателя и вставляем туда наш хвост и возвращаем полученную строку.
 * Например, были переданны строки "двадцать один" и "одна". Функция вернёт "двадцать одна".
 * 
 * Принимает:
 *  1. указатель на строку "*line" (строка), в которой будет искаться "*tail"
 * 	2. указатель на строку "*tail" (хвост), которая будет проверяться на вхождениние в конец строки "*line"
 * 
 * Возвращает: указатель на строку "*lain"
 * 
 * @param quan_line (quantity - количество) - количество символов в строке *line
 * @param quan_tail - количество символов в строке *tail
 * @param *str - дубликат указателя *line, с который мы будем разбивать
 */
char* replace_tail (char *line, char *tail)
{
	int quan_line = strlen (line);
	int quan_tail = strlen (tail);
	char *str = line;								/// Создаём дубликат указателя *line
	str = line + quan_line - quan_tail;				/// Перемещаем указатель строки на нужное нам место
	*str = '\0';									/// Ставим на его место знак окончания строки
	strcat (line, tail);
	
	return line;
}

/**
 * @fn type_hour
 * @brief Функция для определения типа слова "час"
 * Функция определяет, когда нужно говорить "час", когда "часа", а когда "часов".
 * Например, "один час", "два часа" или "пять часов"
 * 
 * Принимает:
 * 	1. Указатель на строку "str", в которую будет записано одно из трёх слов - "час", "часа" или "часов"
 * 	2. Строку "hour", в которой хранится то, сколько сейчас часов в цифровом формате, например "4" или "17"
 * 
 * Возвращает:
 * 	1. Указатель на строку "str_hour", в которой записано одно из трёх форм слова "час"
 * 
 * @param hour_word - в нём хранится время часов, записанное в словесном выражении
 * @param *str_num - указатель на "hour_word", использующийся для передачи в функцию
 */
char* type_hour (char* str_hour, char* hour)
{
	char hour_word [60], *str_num;
	strcpy (hour_word, hour);						/// Копируем "hour" в hour_word, потому что в hour_word места больше
	str_num = hour_word;
	str_num = transl_number (str_num);				/// Отправляем "str_num" в "transl_number, чтобы получить часы в словесном выражении
	strcpy (str_hour, "часов");						/// По умолчанию, в "str_hour" будет значение "минут" и оно таким и останется, если не пройдёт ни одно условие			
	
	if (find_tail (str_num, "один") == true)		/// Если в конце "один", значит говорим "час"
	{
		strcpy (str_hour, "час");
		return str_hour;		
	}
	if (find_tail (str_num, "два") == true)			/// Если в конце "два", значит говорим "часа"
	{
		strcpy (str_hour, "часа");
		return str_hour;	
	}
	/// А если в конце "три" или "четыре", то говорим "часа" 	
	if (find_tail (str_num, "три") == true || find_tail (str_num, "четыре") == true)
		strcpy (str_hour, "часа");
	else
		strcpy (str_hour, "часов");					/// Во всех остальных случаях говорим "часов"
		
	return str_hour;
}

/**
 * @fn type_min
 * @brief Функция для определения типа слова "минита"
 * Функция определяет, когда нужно говорить "минута", когда "минут", а когда "минуты".
 * Например, "одна минута", "две минуты" или "пять минут"
 * 
 * Принимает:
 * 	1. Указатель на строку "str_min", в которую будет записано одно из трёх слов - "минута", "минут" или "минуты"
 * 	2. Строку "minuts", в которой хранится то, сколько сейчас часов в цифровом формате, например "4" или "17"
 * 
 * Возвращает:
 * 	1. Указатель на строку "str_min", в которой записано одно из трёх форм слова "час"
 * 
 * @param min_word - в нём хранится время минут, записанное в словесном выражении
 * @param *str_num - указатель на "min_word", использующийся для передачи в функцию
 */
char* type_min (char* str_min, char* minuts)
{
	char min_word [60], *str_num;
	strcpy (min_word, minuts);						/// Копируем "minuts" в min_word, потому что в min_word места больше
	str_num = min_word;
	str_num = transl_number (str_num);				/// Отправляем "str_num" в transl_number, чтобы получить число в словесном написании 
		
	if (find_tail (str_num, "один") == true)		/// Если в конце "один", значит говорим "минута"
	{
		strcpy (str_min, "минута");
		return str_min;
	}
	
	/// Если в конце "два" (две), "три" или "четыре", то говорим "минуты"
	if (find_tail (str_num, "два") == true || find_tail (str_num, "три") == true || find_tail (str_num, "четыре") == true)
	{
		strcpy (str_min, "минуты");
		return str_min;
	}
	else
		return strcpy (str_min, "минут");			/// Во всех остальных случаях говорим "минут"
}
/**
 * @fn settime
 * @brief Функция для определения времени, его корректной записи и внесения полученной записи в файл
 * 
 * Принимает: указатель на структуру tm - *u
 * Возвращает: ничего
 * 
 * @param *fd - указатель на открываемый файл
 * @param hour, minuts - строки, в которые записываются часы и минуты соответственно, в числовом формате
 * @param hour_word - строка, в которой хранится вариант записи слова "час" - "час", "часа" и "часов"
 * @param min_word - строка, в которой хранится вариант записи слова "минута" - "минута", "минуты" и "минут"
 * @param min_in_word - строка, в которой хранится текущее количество минут, записанное в словесном варинте
 * @param str_hour_word - указатель на строку hour_word
 * @param str_min_word - указатель на строку min_word
 * @param str_min_in_word - указатель на строку min_in_word
 */
void settime (struct tm *u)
{
	FILE *fd;
	char hour [10], minuts [60], hour_word [10], min_word [15], *str_hour_word, *str_min_word, *str_minuts;
	
	fd = fopen ("/tmp/voice_text.txt", "w");	
	str_hour_word = hour_word;										/// Создаём указатели на те
	str_min_word = min_word;										/// строки, которые которые мы
	str_minuts = minuts;											/// планируем передавать в функции
	
	strftime (hour, 10, "%H", u);									/// Записываем в hour количество часов
	strftime (minuts, 60, "%M", u);									/// Записываем в minuts количество минут
	
	/**В следующем блоке кода мы определяем, в какой форме нужно употребить слова "час" и "минута" в зависимости от того, сколько
	 * сейчас часов или минут, при помощи функций type_hour и type_min. Например, 2 часа, или 12 часов. 1 минута или 29 минут.
	 * В третьей строке мы отправляем количество минут в числовом варианте в фунцию transl_number, чтобы получить то же число в 
	 * словесном написании.
	 */
	str_hour_word = type_hour (str_hour_word, hour);
	str_min_word = type_min (str_min_word, minuts);
	str_minuts = transl_number (str_minuts);
	
	/**При написании минут в словесной форме, если в конце стоит "один" или "два", то нужно их поменять на "одна" или "две"
	 * соответственно, чтобы они сочитались с "минута" и "минуты".
	 * Сначала, с помощью функции find_tail мы выясняем, является ли 2-ой переданный аргумент окончанием 1-го и если да, то
	 * при помощи функции replace_tail мы заменяем конец 1-го аргумента на то, что было переданно как 2-ой аргумент.
	 * В 3-ей и 4-ой строчке всё аналогично.
	 */
	if (find_tail (str_minuts, "один") == true)
		str_minuts = replace_tail (str_minuts, "одна");
	else if (find_tail (str_minuts, "два") == true)
		str_minuts = replace_tail (str_minuts, "две");
		
	fprintf (fd, "Время - %s %s, %s %s", hour, str_hour_word, str_minuts, str_min_word);
	fflush (fd);
}

/**
 * @fn main
 * @brief Функция для вызова функции settime и вызова программы для озвучки того, что стало результатом работы первой функции
 * Принимает: ничего
 * Возвращает: "0", если всё хорошо, не "0", если это не так
 * @param tm *u указатель на структуру tm
 */
int main()
{
	struct tm *u;
	const time_t timer = time (NULL);
	u = localtime (&timer);
	settime (u);
	system ("festival -b '(begin (voice_msu_ru_nsh_clunits) (tts_file \"/tmp/voice_text.txt\"))'");
	return 0;
}
